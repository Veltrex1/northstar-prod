import Anthropic from '@anthropic-ai/sdk';
import { DraftStatus, EmailStatus } from '@prisma/client';
import type { Contact, ContactInteraction, Email, User } from '@prisma/client';
import { prisma } from '@/lib/db/prisma';
import { buildContext, type ContextResult } from '@/lib/ai/context-engine';
import { logger } from '@/lib/utils/logger';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY!,
});

const MODEL = 'claude-sonnet-4-20250514';
const MAX_TOKENS = 2000;
const TEMPERATURE = 0.7;
const MAX_THREAD_MESSAGES = 6;
const MAX_INTERACTIONS = 5;

type DraftContext = {
  threadHistory: string;
  knowledgeContext?: string;
  contactContext?: string;
  interactionContext?: string;
};


export async function generateAutoDraft(emailId: string) {
  try {
    logger.info('Generating auto draft', { emailId });

    const email = await prisma.email.findUnique({
      where: { id: emailId },
    });

    if (!email) {
      throw new Error('Email not found');
    }

    const user = await prisma.user.findUnique({
      where: { id: email.userId },
    });

    if (!user) {
      throw new Error('User not found');
    }

    const threadHistory = await fetchThreadHistory(email);
    const { contact, contactContext, interactionContext, interactions } =
      await fetchContactContext(email);

    const useSecondBrain = await isSecondBrainEnabled(user.companyId);
    const knowledgeContext = useSecondBrain
      ? await resolveKnowledgeContext({
          email,
          user,
          threadHistory,
          contact,
          interactions,
          useSecondBrain,
        })
      : undefined;

    const context: DraftContext = {
      threadHistory,
      knowledgeContext,
      contactContext,
      interactionContext,
    };

    const { systemPrompt, userPrompt } = buildDraftPrompt(email, user, context);
    const response = await anthropic.messages.create({
      model: MODEL,
      max_tokens: MAX_TOKENS,
      temperature: TEMPERATURE,
      system: systemPrompt,
      messages: [{ role: 'user', content: userPrompt }],
    });

    const generatedContent = extractClaudeText(response);

    if (!generatedContent) {
      throw new Error('Claude returned empty response');
    }

    const draft = await prisma.emailDraft.create({
      data: {
        userId: user.id,
        emailId: email.id,
        threadId: email.threadId,
        subject: `Re: ${email.subject}`,
        content: generatedContent.trim(),
        status: DraftStatus.DRAFT,
        isAutoGenerated: true,
        generatedAt: new Date(),
      },
    });

    await prisma.email.update({
      where: { id: email.id },
      data: { status: EmailStatus.DRAFT_READY },
    });

    return draft;
  } catch (error) {
    logger.error('Auto draft generation error', error);
    throw error;
  }
}

export function buildDraftPrompt(email: Email, user: User, context: DraftContext) {
  const personalityProfile = formatProfile(user.personalityProfile, 'Personality');
  const voiceProfile = formatProfile(user.voiceProfile, 'Voice');

  const systemPrompt = `You are an expert email drafting assistant.

Match the user's communication style and tone precisely.

${personalityProfile}

${voiceProfile}

Guidelines:
- Write as if you are the user.
- Be concise and respond directly to the sender's intent.
- Preserve the user's typical greeting and closing style.
- Do not invent facts; rely only on provided context.
- Return only the email body, without subject lines or labels.`;

  const userPrompt = buildUserPrompt(email, context);

  return { systemPrompt, userPrompt };
}

async function fetchThreadHistory(email: Email): Promise<string> {
  if (!email.threadId) {
    return 'No thread history available.';
  }

  const threadEmails = await prisma.email.findMany({
    where: {
      threadId: email.threadId,
      userId: email.userId,
    },
    orderBy: { receivedAt: 'desc' },
    take: MAX_THREAD_MESSAGES,
  });

  if (threadEmails.length === 0) {
    return 'No thread history available.';
  }

  return threadEmails
    .slice()
    .reverse()
    .map((threadEmail, index) => {
      const body = truncateText(threadEmail.body, 1200);
      return `Message ${index + 1}
From: ${threadEmail.from}
Subject: ${threadEmail.subject}
Received: ${threadEmail.receivedAt.toISOString()}
Body:
${body}`;
    })
    .join('\n\n');
}

async function fetchContactContext(email: Email): Promise<{
  contact: Contact | null;
  interactions: ContactInteraction[];
  contactContext?: string;
  interactionContext?: string;
}> {
  const contact = await prisma.contact.findFirst({
    where: {
      userId: email.userId,
      email: email.from,
    },
  });

  if (!contact) {
    return {
      contact: null,
      interactions: [],
      contactContext: 'No contact profile found.',
      interactionContext: 'No recent interactions found.',
    };
  }

  const interactions = await prisma.contactInteraction.findMany({
    where: { contactId: contact.id },
    orderBy: { timestamp: 'desc' },
    take: MAX_INTERACTIONS,
  });

  return {
    contact,
    interactions,
    contactContext: buildContactContext(contact),
    interactionContext: buildInteractionContext(interactions),
  };
}

async function resolveKnowledgeContext(input: {
  email: Email;
  user: User;
  threadHistory: string;
  contact: Contact | null;
  interactions: ContactInteraction[];
  useSecondBrain: boolean;
}): Promise<string> {
  try {
    const query = [input.email.subject, input.email.body, input.threadHistory]
      .filter(Boolean)
      .join('\n');
    const result = await buildContext(query, input.user.id, {
      includeDocuments: input.useSecondBrain,
      includeContacts: Boolean(input.contact),
      includeEmails: true,
      includeCalendar: true,
      includeMemories: true,
    });

    return formatContextForDraft(result);
  } catch (error) {
    logger.error('Knowledge context build error', error);
    return '';
  }
}

async function isSecondBrainEnabled(companyId: string): Promise<boolean> {
  try {
    const count = await prisma.knowledgeEntry.count({
      where: { companyId },
    });

    return count > 0;
  } catch (error) {
    logger.error('Second Brain check error', error);
    return false;
  }
}

function buildUserPrompt(email: Email, context: DraftContext): string {
  const sections = [
    `ORIGINAL EMAIL:
From: ${email.from}
Subject: ${email.subject}
Body:
${email.body}`,
  ];

  if (context.threadHistory) {
    sections.push(`THREAD HISTORY:\n${context.threadHistory}`);
  }

  if (context.knowledgeContext) {
    sections.push(`RELEVANT KNOWLEDGE:\n${context.knowledgeContext}`);
  }

  if (context.contactContext) {
    sections.push(`CONTACT CONTEXT:\n${context.contactContext}`);
  }

  if (context.interactionContext) {
    sections.push(`RECENT INTERACTIONS:\n${context.interactionContext}`);
  }

  sections.push('Draft a reply to the original email.');

  return sections.join('\n\n');
}

function buildContactContext(contact: Contact): string {
  const details = [
    `Name: ${contact.name}`,
    `Email: ${contact.email}`,
    contact.company ? `Company: ${contact.company}` : null,
    contact.title ? `Title: ${contact.title}` : null,
    `Category: ${contact.category}`,
    contact.vipStatus ? 'VIP: Yes' : 'VIP: No',
    contact.notes ? `Notes: ${contact.notes}` : null,
  ].filter(Boolean);

  return details.join('\n');
}

function buildInteractionContext(interactions: ContactInteraction[]): string {
  if (interactions.length === 0) {
    return 'No recent interactions found.';
  }

  return interactions
    .map((interaction) => {
      const summary = interaction.summary
        ? truncateText(interaction.summary, 500)
        : 'No summary provided.';
      return `${interaction.timestamp.toISOString()} â€¢ ${interaction.type}
Subject: ${interaction.subject || 'No subject'}
Summary: ${summary}`;
    })
    .join('\n\n');
}

function formatContextForDraft(context: ContextResult): string {
  const sections: string[] = [];

  if (context.documents.length > 0) {
    sections.push(
      `DOCUMENTS:\n${context.documents
        .map((doc) => `- ${doc.title}: ${truncateText(doc.content, 400)}`)
        .join('\n')}`
    );
  }

  if (context.conversations.length > 0) {
    sections.push(
      `PAST CONVERSATIONS:\n${context.conversations
        .map((conversation) => {
          const title = conversation.title || 'Untitled conversation';
          return `- ${title} (${conversation.updatedAt.toISOString()})`;
        })
        .join('\n')}`
    );
  }

  if (context.emails.length > 0) {
    sections.push(
      `RELATED EMAILS:\n${context.emails
        .map((email) => `- ${email.subject}: ${truncateText(email.body, 300)}`)
        .join('\n')}`
    );
  }

  if (context.contacts.length > 0) {
    sections.push(
      `RELATED CONTACTS:\n${context.contacts
        .map((contact) => `- ${contact.name} (${contact.email})`)
        .join('\n')}`
    );
  }

  if (context.calendar.length > 0) {
    sections.push(
      `UPCOMING/RECENT MEETINGS:\n${context.calendar
        .map((event) => `- ${event.title} (${event.startTime.toISOString()})`)
        .join('\n')}`
    );
  }

  if (context.memories.length > 0) {
    sections.push(
      `MEMORIES:\n${context.memories
        .map((memory) => `- ${memory.title}: ${truncateText(memory.content, 300)}`)
        .join('\n')}`
    );
  }

  return sections.length > 0 ? sections.join('\n\n') : '';
}

function formatProfile(profile: User['personalityProfile'], label: string): string {
  if (!profile) {
    return `${label} Profile: Not provided.`;
  }

  return `${label} Profile:\n${JSON.stringify(profile, null, 2)}`;
}

function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) {
    return text;
  }

  return `${text.slice(0, maxLength)}...`;
}

function extractClaudeText(response: Anthropic.Messages.Message): string {
  const content = response.content[0];
  if (content?.type === 'text') {
    return content.text;
  }
  return '';
}
